name: Build & Deploy (GHCR + Docker Compose)

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  IMAGE_OWNER: ${{ github.repository_owner }}
  IMAGE_TAG: ${{ github.sha }}
  VM_USER: ${{ secrets.VM_USER || 'vodeneevm' }}

jobs:
  build_and_push:
    name: Build & push images to GHCR
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: parser
            dockerfile: internal/parser/Dockerfile
            image: vodeneevbet-parser
          - service: calculator
            dockerfile: internal/calculator/Dockerfile
            image: vodeneevbet-calculator
          - service: telegram-bot
            dockerfile: cmd/telegram-bot/Dockerfile
            image: vodeneevbet-telegram-bot
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize image owner (lowercase for GHCR)
        shell: bash
        run: |
          echo "IMAGE_OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ env.IMAGE_OWNER }}/${{ matrix.image }}:${{ env.IMAGE_TAG }}
            ghcr.io/${{ env.IMAGE_OWNER }}/${{ matrix.image }}:main
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy_parsers:
    name: Deploy parsers VM (docker compose)
    runs-on: ubuntu-latest
    needs: build_and_push
    env:
      VM_HOST: ${{ secrets.VM_PARSERS_HOST }}
      REMOTE_DIR: /opt/vodeneevbet/parsers
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME || github.repository_owner }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      YC_SERVICE_ACCOUNT_KEY_JSON: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_JSON }}
      YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
      YC_LOG_GROUP_ID: ${{ secrets.YC_LOG_GROUP_ID }}
      YC_LOG_GROUP_NAME: ${{ secrets.YC_LOG_GROUP_NAME || 'default' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize image owner (lowercase for GHCR)
        shell: bash
        run: |
          echo "IMAGE_OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add VM to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "${VM_HOST}" >> ~/.ssh/known_hosts

      - name: Upload docker-compose.yml and nginx.conf
        run: |
          ssh "${VM_USER}@${VM_HOST}" "sudo mkdir -p '${REMOTE_DIR}' && sudo chown -R '${VM_USER}:${VM_USER}' '${REMOTE_DIR}'"
          # Remove nginx.conf if it exists as a directory (leftover from failed run when file was missing)
          ssh "${VM_USER}@${VM_HOST}" "rm -rf '${REMOTE_DIR}/nginx.conf'"
          scp "deploy/vm-parsers/docker-compose.yml" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/docker-compose.yml"
          scp "deploy/vm-parsers/nginx.conf" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/nginx.conf"

      - name: Upload configs
        run: |
          ssh "${VM_USER}@${VM_HOST}" "mkdir -p '${REMOTE_DIR}/configs'"
          rsync -az --delete "configs/" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/configs/"

      - name: Pull & up
        run: |
          if [ -z "${GHCR_TOKEN}" ]; then
            echo "GHCR_TOKEN is not set. Add it as a GitHub Actions secret to pull private images from ghcr.io" >&2
            exit 1
          fi

          # Login by streaming token via stdin (avoid quoting issues).
          printf %s "${GHCR_TOKEN}" | ssh "${VM_USER}@${VM_HOST}" "sudo docker login ghcr.io -u \"${GHCR_USERNAME}\" --password-stdin"

          # Run the deploy script on the VM via stdin (avoid nested quote escaping).
          ssh "${VM_USER}@${VM_HOST}" "REMOTE_DIR='${REMOTE_DIR}' IMAGE_OWNER='${IMAGE_OWNER}' IMAGE_TAG='${IMAGE_TAG}' YC_SERVICE_ACCOUNT_KEY_JSON='${YC_SERVICE_ACCOUNT_KEY_JSON:-}' YC_FOLDER_ID='${YC_FOLDER_ID:-}' YC_LOG_GROUP_ID='${YC_LOG_GROUP_ID:-}' YC_LOG_GROUP_NAME='${YC_LOG_GROUP_NAME:-default}' bash -s" <<'EOF'
          set -euo pipefail
          cd "${REMOTE_DIR}"

          # Compose automatically reads .env from the project directory
          # Используем base64 для безопасной передачи JSON через .env файл
          if [ -n "${YC_SERVICE_ACCOUNT_KEY_JSON:-}" ]; then
            # Убираем только форматирующие переносы строк (между токенами JSON)
            # Но сохраняем экранированные \n внутри строковых значений
            # Используем простой подход: заменяем переносы строк на пробелы, но только между токенами
            # Это безопаснее, чем пытаться минифицировать через jq (может быть проблема с управляющими символами)
            YC_SERVICE_ACCOUNT_KEY_JSON_CLEANED=$(printf '%s' "${YC_SERVICE_ACCOUNT_KEY_JSON}" | tr '\n\r' ' ' | sed 's/  */ /g')
            # Кодируем очищенный JSON в base64 для безопасной передачи через .env файл
            YC_SERVICE_ACCOUNT_KEY_JSON_B64=$(printf '%s' "${YC_SERVICE_ACCOUNT_KEY_JSON_CLEANED}" | base64 -w 0)
            printf "IMAGE_OWNER=%s\nIMAGE_TAG=%s\nYC_SERVICE_ACCOUNT_KEY_JSON_B64=%s\nYC_FOLDER_ID=%s\nYC_LOG_GROUP_ID=%s\nYC_LOG_GROUP_NAME=%s\n" \
              "${IMAGE_OWNER}" "${IMAGE_TAG}" "${YC_SERVICE_ACCOUNT_KEY_JSON_B64}" "${YC_FOLDER_ID:-}" "${YC_LOG_GROUP_ID:-}" "${YC_LOG_GROUP_NAME:-default}" > .env
          else
            printf "IMAGE_OWNER=%s\nIMAGE_TAG=%s\nYC_FOLDER_ID=%s\nYC_LOG_GROUP_ID=%s\nYC_LOG_GROUP_NAME=%s\n" \
              "${IMAGE_OWNER}" "${IMAGE_TAG}" "${YC_FOLDER_ID:-}" "${YC_LOG_GROUP_ID:-}" "${YC_LOG_GROUP_NAME:-default}" > .env
          fi

          # Prefer Compose v2 (docker compose). docker-compose v1 is incompatible with newer Docker versions (e.g. Docker 27+).
          export COMPOSE_PROJECT_NAME=vodeneevbet_parsers
          if docker compose version >/dev/null 2>&1; then
            # Cleanup leftovers from previous runs to avoid container name conflicts
            sudo docker ps -a -q --filter "name=vodeneevbet-parser" | xargs -r sudo docker rm -f
            sudo docker compose down --remove-orphans || true
            sudo docker compose pull
            sudo docker compose up -d --remove-orphans --force-recreate
          elif command -v docker-compose >/dev/null 2>&1; then
            sudo docker ps -a -q --filter "name=vodeneevbet-parser" | xargs -r sudo docker rm -f
            sudo docker-compose down --remove-orphans || true
            sudo docker-compose pull
            sudo docker-compose up -d --remove-orphans --force-recreate
          else
            echo "Docker Compose is not installed (need docker compose plugin or docker-compose)" >&2
            exit 1
          fi

          # Wait for container to be running (avoid flakiness right after up -d)
          ok=0
          for i in {1..30}; do
            if [ "$(sudo docker ps -q -f name=vodeneevbet-parser -f status=running | wc -l)" -ge 1 ]; then
              ok=1
              break
            fi
            sleep 2
          done

          if [ "$ok" -ne 1 ]; then
            echo "Parser container is not running after 60s" >&2
            sudo docker ps -a --filter name=vodeneevbet-parser || true
            sudo docker logs --tail=200 vodeneevbet-parser 2>/dev/null || true
            exit 1
          fi
          EOF

      - name: Debug on failure
        if: failure()
        run: |
          ssh "${VM_USER}@${VM_HOST}" "bash -lc 'set -u
          cd \"${REMOTE_DIR}\" || exit 0
          echo \"--- docker ps -a\"; sudo docker ps -a || true
          echo \"--- docker compose ps\"; (sudo docker compose ps || sudo docker-compose ps) 2>/dev/null || true
          echo \"--- parser logs (tail)\"; sudo docker logs --tail=200 vodeneevbet-parser 2>/dev/null || true
          echo \"--- configs listing\"; ls -la \"${REMOTE_DIR}/configs\" || true
          echo \"--- config head\"; sed -n \"1,120p\" \"${REMOTE_DIR}/configs/production.yaml\" 2>/dev/null || true
          '"

  deploy_core:
    name: Deploy core VM (docker compose)
    runs-on: ubuntu-latest
    needs: build_and_push
    env:
      VM_HOST: ${{ secrets.VM_CORE_HOST }}
      REMOTE_DIR: /opt/vodeneevbet/core
      GHCR_USERNAME: ${{ secrets.GHCR_USERNAME || github.repository_owner }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      POSTGRES_DSN: ${{ secrets.POSTGRES_DSN }}
      YC_SERVICE_ACCOUNT_KEY_JSON: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_JSON }}
      YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
      YC_LOG_GROUP_ID: ${{ secrets.YC_LOG_GROUP_ID }}
      YC_LOG_GROUP_NAME: ${{ secrets.YC_LOG_GROUP_NAME || 'default' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Normalize image owner (lowercase for GHCR)
        shell: bash
        run: |
          echo "IMAGE_OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_CORE || secrets.SSH_PRIVATE_KEY }}

      - name: Add VM to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "${VM_HOST}" >> ~/.ssh/known_hosts

      - name: Upload docker-compose.yml and nginx.conf
        run: |
          ssh "${VM_USER}@${VM_HOST}" "sudo mkdir -p '${REMOTE_DIR}' && sudo chown -R '${VM_USER}:${VM_USER}' '${REMOTE_DIR}'"
          scp "deploy/vm-core/docker-compose.yml" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/docker-compose.yml"
          scp "deploy/vm-core/nginx.conf" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/nginx.conf"

      - name: Upload configs
        run: |
          ssh "${VM_USER}@${VM_HOST}" "mkdir -p '${REMOTE_DIR}/configs'"
          rsync -az --delete "configs/" "${VM_USER}@${VM_HOST}:${REMOTE_DIR}/configs/"

      - name: Pull & up + healthcheck
        run: |
          if [ -z "${GHCR_TOKEN}" ]; then
            echo "GHCR_TOKEN is not set. Add it as a GitHub Actions secret to pull private images from ghcr.io" >&2
            exit 1
          fi

          # Login by streaming token via stdin (avoid quoting issues).
          printf %s "${GHCR_TOKEN}" | ssh "${VM_USER}@${VM_HOST}" "sudo docker login ghcr.io -u \"${GHCR_USERNAME}\" --password-stdin"

          # Run the deploy script on the VM via stdin (avoid nested quote escaping).
          ssh "${VM_USER}@${VM_HOST}" "REMOTE_DIR='${REMOTE_DIR}' IMAGE_OWNER='${IMAGE_OWNER}' IMAGE_TAG='${IMAGE_TAG}' TELEGRAM_BOT_TOKEN='${TELEGRAM_BOT_TOKEN:-}' TELEGRAM_CHAT_ID='${TELEGRAM_CHAT_ID:-}' POSTGRES_DSN='${POSTGRES_DSN:-}' YC_SERVICE_ACCOUNT_KEY_JSON='${YC_SERVICE_ACCOUNT_KEY_JSON:-}' YC_FOLDER_ID='${YC_FOLDER_ID:-}' YC_LOG_GROUP_ID='${YC_LOG_GROUP_ID:-}' YC_LOG_GROUP_NAME='${YC_LOG_GROUP_NAME:-default}' bash -s" <<'EOF'
          set -euo pipefail
          cd "${REMOTE_DIR}"

          # Compose automatically reads .env from the project directory
          # Escape special characters in DSN for safe storage in .env file
          POSTGRES_DSN_ESCAPED="${POSTGRES_DSN//\'/\'\"\'\"\'}"
          # Используем base64 для безопасной передачи JSON через .env файл
          if [ -n "${YC_SERVICE_ACCOUNT_KEY_JSON:-}" ]; then
            # Убираем только форматирующие переносы строк (между токенами JSON)
            # Но сохраняем экранированные \n внутри строковых значений
            # Используем простой подход: заменяем переносы строк на пробелы, но только между токенами
            # Это безопаснее, чем пытаться минифицировать через jq (может быть проблема с управляющими символами)
            YC_SERVICE_ACCOUNT_KEY_JSON_CLEANED=$(printf '%s' "${YC_SERVICE_ACCOUNT_KEY_JSON}" | tr '\n\r' ' ' | sed 's/  */ /g')
            # Кодируем очищенный JSON в base64 для безопасной передачи через .env файл
            YC_SERVICE_ACCOUNT_KEY_JSON_B64=$(printf '%s' "${YC_SERVICE_ACCOUNT_KEY_JSON_CLEANED}" | base64 -w 0)
            printf "IMAGE_OWNER=%s\nIMAGE_TAG=%s\nTELEGRAM_BOT_TOKEN=%s\nTELEGRAM_CHAT_ID=%s\nPOSTGRES_DSN=%s\nYC_SERVICE_ACCOUNT_KEY_JSON_B64=%s\nYC_FOLDER_ID=%s\nYC_LOG_GROUP_ID=%s\nYC_LOG_GROUP_NAME=%s\n" \
              "${IMAGE_OWNER}" "${IMAGE_TAG}" "${TELEGRAM_BOT_TOKEN:-}" "${TELEGRAM_CHAT_ID:-}" "${POSTGRES_DSN_ESCAPED:-}" "${YC_SERVICE_ACCOUNT_KEY_JSON_B64}" "${YC_FOLDER_ID:-}" "${YC_LOG_GROUP_ID:-}" "${YC_LOG_GROUP_NAME:-default}" > .env
          else
            printf "IMAGE_OWNER=%s\nIMAGE_TAG=%s\nTELEGRAM_BOT_TOKEN=%s\nTELEGRAM_CHAT_ID=%s\nPOSTGRES_DSN=%s\nYC_FOLDER_ID=%s\nYC_LOG_GROUP_ID=%s\nYC_LOG_GROUP_NAME=%s\n" \
              "${IMAGE_OWNER}" "${IMAGE_TAG}" "${TELEGRAM_BOT_TOKEN:-}" "${TELEGRAM_CHAT_ID:-}" "${POSTGRES_DSN_ESCAPED:-}" "${YC_FOLDER_ID:-}" "${YC_LOG_GROUP_ID:-}" "${YC_LOG_GROUP_NAME:-default}" > .env
          fi

          # Prefer Compose v2 (docker compose). docker-compose v1 is incompatible with newer Docker versions (e.g. Docker 27+).
          export COMPOSE_PROJECT_NAME=vodeneevbet_core
          if docker compose version >/dev/null 2>&1; then
            sudo docker compose down --remove-orphans || true
            sudo docker compose pull
            sudo docker compose up -d --remove-orphans --force-recreate
          elif command -v docker-compose >/dev/null 2>&1; then
            sudo docker-compose down --remove-orphans || true
            sudo docker-compose pull
            sudo docker-compose up -d --remove-orphans --force-recreate
          else
            echo "Docker Compose is not installed (need docker compose plugin or docker-compose)" >&2
            exit 1
          fi

          # Wait for containers to be running (avoid flakiness right after up -d)
          # Check calculator
          ok=0
          for i in {1..30}; do
            if [ "$(sudo docker ps -q -f name=vodeneevbet-calculator -f status=running | wc -l)" -ge 1 ]; then
              ok=1
              break
            fi
            sleep 2
          done

          if [ "$ok" -ne 1 ]; then
            echo "Calculator container is not running after 60s" >&2
            sudo docker ps -a --filter name=vodeneevbet-calculator || true
            sudo docker logs --tail=200 vodeneevbet-calculator 2>/dev/null || true
            exit 1
          fi

          # Check telegram-bot
          ok=0
          for i in {1..30}; do
            if [ "$(sudo docker ps -q -f name=vodeneevbet-telegram-bot -f status=running | wc -l)" -ge 1 ]; then
              ok=1
              break
            fi
            sleep 2
          done

          if [ "$ok" -ne 1 ]; then
            echo "Telegram-bot container is not running after 60s" >&2
            sudo docker ps -a --filter name=vodeneevbet-telegram-bot || true
            sudo docker logs --tail=200 vodeneevbet-telegram-bot 2>/dev/null || true
            exit 1
          fi
          EOF

      - name: Debug on failure
        if: failure()
        run: |
          ssh "${VM_USER}@${VM_HOST}" "bash -lc 'set -u
          cd \"${REMOTE_DIR}\" || exit 0
          echo \"--- docker ps -a\"; sudo docker ps -a || true
          echo \"--- docker compose ps\"; (sudo docker compose ps || sudo docker-compose ps) 2>/dev/null || true
          echo \"--- calculator logs (tail)\"; sudo docker logs --tail=200 vodeneevbet-calculator 2>/dev/null || true
          echo \"--- telegram-bot logs (tail)\"; sudo docker logs --tail=200 vodeneevbet-telegram-bot 2>/dev/null || true
          echo \"--- configs listing\"; ls -la \"${REMOTE_DIR}/configs\" || true
          echo \"--- config head\"; sed -n \"1,120p\" \"${REMOTE_DIR}/configs/production.yaml\" 2>/dev/null || true
          '"
